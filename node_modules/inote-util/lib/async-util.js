// Generated by CoffeeScript 1.12.7
(function() {
  var AsyncUtil, DEBUG, HOMEDIR, LIB_COV, LIB_DIR, Sequencer, Util, fs, path, ref,
    slice = [].slice,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  fs = require('fs');

  path = require('path');

  HOMEDIR = path.join(__dirname, '..');

  LIB_COV = path.join(HOMEDIR, 'lib-cov');

  LIB_DIR = fs.existsSync(LIB_COV) ? LIB_COV : path.join(HOMEDIR, 'lib');

  Util = require(path.join(LIB_DIR, 'util')).Util;

  DEBUG = /(^|,)async-?util($|,)/i.test(typeof process !== "undefined" && process !== null ? (ref = process.env) != null ? ref.NODE_DEBUG : void 0 : void 0);

  AsyncUtil = (function() {
    function AsyncUtil() {}

    AsyncUtil.wait_until = function() {
      var action, args, callback, delay, interval_id, j, predicate;
      predicate = arguments[0], delay = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, j = arguments.length - 1) : (j = 2, []), callback = arguments[j++];
      if (typeof delay === 'function' && (callback == null)) {
        callback = delay;
        delay = null;
      }
      delay = Util.to_int(delay);
      if ((delay != null) && delay < 0) {
        delay = null;
      }
      if (delay == null) {
        delay = 100;
      }
      interval_id = null;
      action = function() {
        return process.nextTick(function() {
          var e, err, wait_over;
          wait_over = null;
          err = null;
          try {
            wait_over = predicate();
          } catch (error) {
            e = error;
            err = e;
          }
          if (wait_over !== false) {
            AsyncUtil.cancel_interval(interval_id);
            if (typeof callback === "function") {
              callback(err, wait_over);
            }
            return callback = null;
          }
        });
      };
      interval_id = AsyncUtil.interval.apply(AsyncUtil, [delay].concat(slice.call(args), [action]));
      return interval_id;
    };

    AsyncUtil.wait_for = function(predicate, delay, callback) {
      return AsyncUtil.wait_until(predicate, delay, callback);
    };

    AsyncUtil.wait = function() {
      var args, cb, delay, fn, j;
      delay = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, j = arguments.length - 1) : (j = 1, []), cb = arguments[j++];
      fn = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return process.nextTick(function() {
          return cb.apply(null, args);
        });
      };
      return setTimeout.apply(null, [fn, delay].concat(slice.call(args)));
    };

    AsyncUtil.set_timeout = function() {
      var args, cb, delay, j;
      delay = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, j = arguments.length - 1) : (j = 1, []), cb = arguments[j++];
      return AsyncUtil.wait.apply(AsyncUtil, [delay].concat(slice.call(args), [cb]));
    };

    AsyncUtil.setTimeout = function() {
      var args, cb, delay, j;
      delay = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, j = arguments.length - 1) : (j = 1, []), cb = arguments[j++];
      return AsyncUtil.wait.apply(AsyncUtil, [delay].concat(slice.call(args), [cb]));
    };

    AsyncUtil.cancel_wait = function(id) {
      return clearTimeout(id);
    };

    AsyncUtil.cancelWait = function(id) {
      return AsyncUtil.cancel_wait(id);
    };

    AsyncUtil.cancelTimeout = function(id) {
      return AsyncUtil.cancel_wait(id);
    };

    AsyncUtil.cancel_timeout = function(id) {
      return AsyncUtil.cancel_wait(id);
    };

    AsyncUtil.clearTimeout = function(id) {
      return AsyncUtil.cancel_wait(id);
    };

    AsyncUtil.clear_timeout = function(id) {
      return AsyncUtil.cancel_wait(id);
    };

    AsyncUtil.clearWait = function(id) {
      return AsyncUtil.cancel_wait(id);
    };

    AsyncUtil.clear_wait = function(id) {
      return AsyncUtil.cancel_wait(id);
    };

    AsyncUtil.interval = function() {
      var args, cb, delay, j;
      delay = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, j = arguments.length - 1) : (j = 1, []), cb = arguments[j++];
      return setInterval.apply(null, [cb, delay].concat(slice.call(args)));
    };

    AsyncUtil.set_interval = function() {
      var args, cb, delay, j;
      delay = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, j = arguments.length - 1) : (j = 1, []), cb = arguments[j++];
      return AsyncUtil.interval.apply(AsyncUtil, [delay].concat(slice.call(args), [cb]));
    };

    AsyncUtil.setInterval = function() {
      var args, cb, delay, j;
      delay = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, j = arguments.length - 1) : (j = 1, []), cb = arguments[j++];
      return AsyncUtil.interval.apply(AsyncUtil, [delay].concat(slice.call(args), [cb]));
    };

    AsyncUtil.cancel_interval = function(id) {
      return clearInterval(id);
    };

    AsyncUtil.cancelInterval = function(id) {
      return AsyncUtil.cancel_interval(id);
    };

    AsyncUtil.clear_interval = function(id) {
      return AsyncUtil.cancel_interval(id);
    };

    AsyncUtil.clearInterval = function(id) {
      return AsyncUtil.cancel_interval(id);
    };

    AsyncUtil.for_async = function(initialize, condition, action, increment, whendone) {
      var looper;
      looper = function() {
        if (condition()) {
          return action(function() {
            increment();
            return looper();
          });
        } else {
          if (whendone != null) {
            return whendone();
          }
        }
      };
      initialize();
      return looper();
    };

    AsyncUtil.for_each_async = function(list, action, whendone) {
      var act, cond, i, incr, init, m;
      i = m = null;
      init = function() {
        return i = 0;
      };
      cond = function() {
        return i < list.length;
      };
      incr = function() {
        return i += 1;
      };
      act = function(next) {
        return action(list[i], i, list, next);
      };
      return AsyncUtil.for_async(init, cond, act, incr, whendone);
    };

    AsyncUtil.fork_for_each_async = function(list, action, whendone) {
      var args, elt, i, j, len, methods;
      methods = list.map(function() {
        return action;
      });
      args = [];
      for (i = j = 0, len = list.length; j < len; i = ++j) {
        elt = list[i];
        args.push([elt, i, list]);
      }
      return AsyncUtil.fork(methods, args, whendone);
    };

    AsyncUtil.throttled_fork_for_each_async = function(max_parallel, list, action, whendone) {
      var args, elt, i, j, len, methods;
      methods = list.map(function() {
        return action;
      });
      args = [];
      for (i = j = 0, len = list.length; j < len; i = ++j) {
        elt = list[i];
        args.push([elt, i, list]);
      }
      return AsyncUtil.throttled_fork(max_parallel, methods, args, whendone);
    };

    AsyncUtil.fork = function(methods, args_for_methods, callback) {
      var index, j, len, method, remaining_callbacks, results, results1;
      if ((callback == null) && (typeof args_for_methods === 'function')) {
        callback = args_for_methods;
        args_for_methods = null;
      }
      results = [];
      remaining_callbacks = methods.length;
      results1 = [];
      for (index = j = 0, len = methods.length; j < len; index = ++j) {
        method = methods[index];
        results1.push((function(method, index) {
          var method_args, ref1;
          method_args = (ref1 = args_for_methods != null ? args_for_methods[index] : void 0) != null ? ref1 : [];
          if (!Array.isArray(method_args)) {
            method_args = [method_args];
          }
          return method.apply(null, slice.call(method_args).concat([function() {
            var callback_args;
            callback_args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            results[index] = callback_args;
            remaining_callbacks--;
            if (remaining_callbacks === 0) {
              return callback(results);
            }
          }]));
        })(method, index));
      }
      return results1;
    };

    AsyncUtil.throttled_fork = function(max_parallel, methods, args_for_methods, callback) {
      var currently_running, next_to_run, remaining_callbacks, results, run_more;
      if ((callback == null) && typeof args_for_methods === 'function') {
        callback = args_for_methods;
        args_for_methods = null;
      }
      results = [];
      currently_running = 0;
      next_to_run = 0;
      remaining_callbacks = methods.length;
      run_more = function() {
        var index, results1;
        results1 = [];
        while ((currently_running < max_parallel) && (next_to_run < methods.length)) {
          index = next_to_run;
          currently_running++;
          next_to_run++;
          results1.push((function(index) {
            var method, method_args, ref1;
            method_args = (ref1 = args_for_methods != null ? args_for_methods[index] : void 0) != null ? ref1 : [];
            if (!Array.isArray(method_args)) {
              method_args = [method_args];
            }
            method = methods[index];
            return method.apply(null, slice.call(method_args).concat([function() {
              var callback_args;
              callback_args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              results[index] = callback_args;
              currently_running--;
              remaining_callbacks--;
              if (remaining_callbacks === 0) {
                return callback(results);
              } else {
                return run_more();
              }
            }]));
          })(index));
        }
        return results1;
      };
      return run_more();
    };

    AsyncUtil.procedure = function() {
      return new Sequencer();
    };

    return AsyncUtil;

  })();

  Sequencer = (function() {
    function Sequencer() {
      this.run = bind(this.run, this);
      this["finally"] = bind(this["finally"], this);
      this.last = bind(this.last, this);
      this.then = bind(this.then, this);
      this.next = bind(this.next, this);
      this.first = bind(this.first, this);
      this.list = [];
    }

    Sequencer.prototype.first = function(step) {
      this.list = [];
      this.list.push(step);
      return this;
    };

    Sequencer.prototype.next = function(step) {
      this.list.push(step);
      return this;
    };

    Sequencer.prototype.then = function(step) {
      return this.next(step);
    };

    Sequencer.prototype.last = function(step, callback) {
      this.next(step);
      this.run(callback);
      return this;
    };

    Sequencer.prototype["finally"] = function(step, callback) {
      return this.last(step, callback);
    };

    Sequencer.prototype.run = function() {
      var action, args, callback, j;
      args = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), callback = arguments[j++];
      action = (function(_this) {
        return function(step, index, list, next) {
          return step.apply(null, slice.call(args).concat([function() {
            var new_args;
            new_args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            args = new_args;
            return next();
          }]));
        };
      })(this);
      AsyncUtil.for_each_async(this.list, action, (function(_this) {
        return function() {
          return typeof callback === "function" ? callback.apply(null, args) : void 0;
        };
      })(this));
      return this;
    };

    return Sequencer;

  })();

  exports.AsyncUtil = AsyncUtil;

  exports.Sequencer = Sequencer;

}).call(this);
