// Generated by CoffeeScript 1.12.7
(function() {
  var AsyncUtil, DustUtil, FileUtil, HOME_DIR, L10nUtil, LIB_COV, LIB_DIR, LogUtil, ObjectUtil, Util, fs, path, sprintf,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  fs = require('fs');

  path = require('path');

  HOME_DIR = path.join(__dirname, '..');

  LIB_COV = path.join(HOME_DIR, 'lib-cov');

  LIB_DIR = fs.existsSync(LIB_COV) ? LIB_COV : path.join(HOME_DIR, 'lib');

  sprintf = require("sprintf-js").sprintf;

  Util = require(path.join(LIB_DIR, 'util')).Util;

  LogUtil = require(path.join(LIB_DIR, 'log-util')).LogUtil;

  FileUtil = require(path.join(LIB_DIR, 'file-util')).FileUtil;

  AsyncUtil = require(path.join(LIB_DIR, 'async-util')).AsyncUtil;

  ObjectUtil = require(path.join(LIB_DIR, 'object-util')).ObjectUtil;

  DustUtil = require(path.join(LIB_DIR, 'dust-util')).DustUtil.DustUtil;

  L10nUtil = (function() {
    function L10nUtil(config) {
      this.make_localizer = bind(this.make_localizer, this);
      this.load_l10n_files = bind(this.load_l10n_files, this);
      this.parse_locale = bind(this.parse_locale, this);
      this.identify_locales = bind(this.identify_locales, this);
      this.identify_and_expand_locales = bind(this.identify_and_expand_locales, this);
      this.l10n_dust_helper = bind(this.l10n_dust_helper, this);
      this.add_dust_helpers = bind(this.add_dust_helpers, this);
      this.set_dust_util = bind(this.set_dust_util, this);
      var ref;
      if (config == null) {
        config = {};
      }
      this.locale_re = /^([a-z]+)(-([a-z]+))??$/i;
      if ((config.dust != null) || (config.dust_util != null)) {
        this.dust_util = (ref = config.dust_util) != null ? ref : new DustUtil(config.dust);
      }
    }

    L10nUtil.prototype.set_dust_util = function(dust_util) {
      return this.dust_util = dust_util;
    };

    L10nUtil.prototype.add_dust_helpers = function(dust) {
      if (dust instanceof DustUtil) {
        if (this.dust_util == null) {
          this.dust_util = dust;
        }
        dust = dust.dust;
      }
      if ((dust != null) && (this.dust_util == null)) {
        this.dust_util = new DustUtil(dust);
      }
      if (dust == null) {
        if (this.dust_util == null) {
          this.dust_util = new DustUtil();
        }
        dust = this.dust_util.ensure_dust();
      }
      if (dust.helpers == null) {
        dust.helpers = {};
      }
      return dust.helpers.l10n = this.l10n_dust_helper;
    };

    L10nUtil.prototype.l10n_dust_helper = function(chunk, context, bodies, params) {
      var key, localize_fn, match, non_arg_params, pn, pv, ref, ref1, ref2, result, sprintf_args;
      if (this.dust_util == null) {
        this.dust_util = new DustUtil();
      }
      localize_fn = this.dust_util.ctx_get(context, ['localizer', 'localize', 'localization', 'l10n']);
      if (typeof localize_fn === 'object') {
        localize_fn = this.make_localizer(localize_fn);
      }
      if (!((localize_fn != null) && typeof localize_fn === 'function')) {
        LogUtil.tperr("ERROR: l10n helper called but localization is missing or invalid. Will render :else block.");
        localize_fn = function() {
          return null;
        };
      }
      key = (ref = params.key) != null ? ref : this.dust_util.eval_dust_string((ref1 = bodies.block) != null ? ref1 : "", chunk, context);
      key = (ref2 = key != null ? typeof key.trim === "function" ? key.trim() : void 0 : void 0) != null ? ref2 : "";
      sprintf_args = [];
      if ((params.args != null) && Array.isArray(params.args)) {
        sprintf_args = params.args;
      } else if (params.args != null) {
        sprintf_args = (this.dust_util.eval_dust_string(params.args, chunk, context)).split(',');
      } else {
        non_arg_params = null;
        for (pn in params) {
          pv = params[pn];
          pv = this.dust_util.eval_dust_string(pv, chunk, context);
          match = pn.match(/^arg([0-9]+)$/);
          if ((match != null) && (match[1] != null)) {
            sprintf_args[Util.to_int(match[1])] = pv;
          } else if (pn !== 'key') {
            if (non_arg_params == null) {
              non_arg_params = {};
            }
            non_arg_params[pn] = pv;
          }
        }
        if (sprintf_args.length === 0 && (non_arg_params != null)) {
          sprintf_args = non_arg_params;
        }
      }
      result = localize_fn(key, sprintf_args);
      if (result != null) {
        return chunk.write(result);
      } else if (bodies["else"] != null) {
        return chunk.render(bodies["else"], context);
      } else {
        return chunk.write("");
      }
    };

    L10nUtil.prototype.identify_and_expand_locales = function(req) {
      return this.expand_locales(this.identify_locales(req));
    };

    L10nUtil.prototype.identify_locales = function(req) {
      var accept_language, i, j, len, len1, locales, parsed, part, parts, sub_part, sub_parts;
      locales = null;
      if (req != null) {
        accept_language = typeof req.header === "function" ? req.header('accept-language') : void 0;
        if (accept_language != null) {
          parts = accept_language.split(';');
          for (i = 0, len = parts.length; i < len; i++) {
            part = parts[i];
            sub_parts = part.split(',');
            for (j = 0, len1 = sub_parts.length; j < len1; j++) {
              sub_part = sub_parts[j];
              parsed = this.parse_locale(sub_part.trim());
              if (parsed != null) {
                if (locales == null) {
                  locales = [];
                }
                locales.push(parsed);
              }
            }
          }
        }
      }
      return locales;
    };

    L10nUtil.prototype.parse_locale = function(locale) {
      var matches;
      if (locale == null) {
        return locale;
      } else {
        matches = locale != null ? locale.match(this.locale_re) : void 0;
        if ((matches != null ? matches[1] : void 0) != null) {
          return [matches != null ? matches[1] : void 0, matches != null ? matches[3] : void 0];
        } else {
          return null;
        }
      }
    };

    L10nUtil.prototype.expand_locales = function(locales) {
      var i, langs_found, last_lang, len, locale, ref, to_return;
      if (locales == null) {
        return locales;
      } else {
        to_return = [];
        langs_found = [];
        last_lang = null;
        ref = locales != null ? locales : [];
        for (i = 0, len = ref.length; i < len; i++) {
          locale = ref[i];
          if ((last_lang != null) && (locale[0] !== last_lang)) {
            if (indexOf.call(langs_found, last_lang) < 0) {
              to_return.push([last_lang, null]);
              langs_found.push(last_lang);
              last_lang = null;
            }
          }
          to_return.push(locale);
          if (locale[1] == null) {
            langs_found.push(locale[0]);
          } else {
            last_lang = locale[0];
          }
        }
        if ((last_lang != null) && !(indexOf.call(langs_found, last_lang) >= 0)) {
          to_return.push([last_lang, null]);
        }
        return to_return;
      }
    };

    L10nUtil.prototype.match_locale = function(accepted, available, default_value) {
      var i, key, len, locale;
      if (!((accepted != null) && (available != null))) {
        return default_value;
      } else {
        for (i = 0, len = accepted.length; i < len; i++) {
          locale = accepted[i];
          key = locale[0].toLowerCase();
          if (locale[1] != null) {
            key = key + "-" + (locale[1].toLowerCase());
          }
          if (available[key] != null) {
            return key;
          }
        }
        return default_value;
      }
    };

    L10nUtil.prototype.load_l10n_files = function(dir, options, callback) {
      if (typeof options === 'function' && (callback == null)) {
        callback = options;
        options = null;
      }
      if (options == null) {
        options = {};
      }
      if (options.pattern == null) {
        options.pattern = /^.+\.json/;
      }
      return FileUtil.ls(dir, options, (function(_this) {
        return function(err, filelist) {
          var action, available_locales;
          available_locales = {};
          action = function(filename, index, list, next) {
            var full_filename, key;
            key = path.parse(filename).name.toLowerCase();
            full_filename = path.resolve(dir, filename);
            return FileUtil.load_json(full_filename, {
              allow_comments: true,
              strip_comments: true
            }, (function(_this) {
              return function(err, json) {
                if (err != null) {
                  LogUtil.tperr("Encountered error loading " + full_filename + ". The error will be ignored:", err);
                } else if (json != null) {
                  available_locales[key] = json;
                }
                return next();
              };
            })(this));
          };
          return AsyncUtil.for_each_async(filelist, action, function() {
            var name, parsed, value;
            for (name in available_locales) {
              value = available_locales[name];
              parsed = _this.parse_locale(name);
              if ((parsed[1] != null) && (available_locales[parsed[0]] != null)) {
                available_locales[name] = ObjectUtil.merge(available_locales[parsed[0]], value);
              }
            }
            return callback(null, available_locales);
          });
        };
      })(this));
    };

    L10nUtil.prototype.localize = function() {
      var args, key, localization_data, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, str, template;
      localization_data = arguments[0], key = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if ((Array.isArray(args)) && (args.length === 1) && (Array.isArray(args[0]))) {
        args = args[0];
      }
      template = localization_data != null ? localization_data[key] : void 0;
      if (template != null) {
        if ((ref = typeof template) === 'string' || ref === 'number' || ref === 'boolean') {
          return sprintf.apply(null, ["" + template].concat(slice.call(args)));
        } else if (Array.isArray(template)) {
          LogUtil.tperr("Array-valued template at key " + key + " is not supported.");
          return null;
        } else {
          if (template[args != null ? args[0] : void 0] != null) {
            return sprintf.apply(null, ["" + template[args[0]]].concat(slice.call(args)));
          } else if (template["" + (args != null ? args[0] : void 0)] != null) {
            str = "" + args[0];
            return sprintf.apply(null, ["" + template[str]].concat(slice.call(args)));
          } else if ((Util.to_int(args[0]) === 0) && ((template['0'] != null) || (template['none'] != null) || (template[0] != null) || (template['plural'] != null))) {
            return sprintf.apply(null, ["" + ((ref1 = (ref2 = (ref3 = template['0']) != null ? ref3 : template['none']) != null ? ref2 : template[0]) != null ? ref1 : template['plural'])].concat(slice.call(args)));
          } else if ((Util.to_int(args != null ? args[0] : void 0) === 1) && ((template['1'] != null) || (template['one'] != null) || (template[1] != null) || (template['singular'] != null))) {
            return sprintf.apply(null, ["" + ((ref4 = (ref5 = (ref6 = template['1']) != null ? ref6 : template['one']) != null ? ref5 : template[1]) != null ? ref4 : template['singular'])].concat(slice.call(args)));
          } else if ((Util.to_int(args != null ? args[0] : void 0) > 1) && ((template['2'] != null) || (template['many'] != null) || (template[2] != null) || (template['plural'] != null))) {
            return sprintf.apply(null, ["" + ((ref7 = (ref8 = (ref9 = template['2']) != null ? ref9 : template['many']) != null ? ref8 : template[2]) != null ? ref7 : template['plural'])].concat(slice.call(args)));
          } else if (((args != null ? args[0] : void 0) == null) && (template['null'] != null)) {
            return sprintf.apply(null, ["" + template['null']].concat(slice.call(args)));
          } else if (((args != null ? args[0] : void 0) != null) && ((template['not-null'] != null) || (template['not_null'] != null) || template['notnull'])) {
            return sprintf.apply(null, ["" + ((ref10 = (ref11 = template['not-null']) != null ? ref11 : template['not_null']) != null ? ref10 : template['notnull'])].concat(slice.call(args)));
          } else {
            return null;
          }
        }
      } else {
        return null;
      }
    };

    L10nUtil.prototype.make_localizer = function(localization_data) {
      return (function(_this) {
        return function() {
          var args, key;
          key = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          return _this.localize.apply(_this, [localization_data, key].concat(slice.call(args)));
        };
      })(this);
    };

    return L10nUtil;

  })();

  exports.L10nUtil = new L10nUtil();

  exports.L10nUtil.constructor = exports.L10nUtil.L10nUtil = L10nUtil;

  exports.L10nUtil.init = function(config) {
    return new L10nUtil(config);
  };

}).call(this);
