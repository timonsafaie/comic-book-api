// Generated by CoffeeScript 1.11.1
(function() {
  var ConnectionFactory, HOMEDIR, LIB_COV, LIB_DIR, PostgreSQLClient, PostgreSQLClient2, PostgreSQLClientPool, PostgreSQLClientPool2, PostgreSQLConnectionFactory, PostgreSQLConnectionFactory2, SQLClient, SQLClientPool, Url, error, fs, path, pg, querystring,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  fs = require('fs');

  path = require('path');

  HOMEDIR = path.join(__dirname, '..');

  LIB_COV = path.join(HOMEDIR, 'lib-cov');

  LIB_DIR = fs.existsSync(LIB_COV) ? LIB_COV : path.join(HOMEDIR, 'lib');

  SQLClient = require(path.join(LIB_DIR, 'sql-client')).SQLClient;

  SQLClientPool = require(path.join(LIB_DIR, 'sql-client-pool')).SQLClientPool;

  ConnectionFactory = require(path.join(LIB_DIR, 'connection-factory')).ConnectionFactory;

  pg = require('pg');

  Url = require('url');

  querystring = require('querystring');

  try {
    if (pg.__lookupGetter__("native") == null) {
      pg = pg["native"];
    }
  } catch (error1) {
    error = error1;
    console.log(error);
  }

  PostgreSQLConnectionFactory = (function(superClass) {
    extend(PostgreSQLConnectionFactory, superClass);

    function PostgreSQLConnectionFactory() {
      this.pre_process_sql = bind(this.pre_process_sql, this);
      this.open_connection = bind(this.open_connection, this);
      PostgreSQLConnectionFactory.__super__.constructor.call(this);
    }

    PostgreSQLConnectionFactory.prototype.open_connection = function(connect_string, callback) {
      var connection;
      connection = new pg.Client(connect_string);
      return connection.connect((function(_this) {
        return function(err) {
          return callback(err, connection);
        };
      })(this));
    };

    PostgreSQLConnectionFactory.prototype.pre_process_sql = function(sql, bindvars, callback) {
      var index;
      if ((sql != null) && (bindvars != null)) {
        index = 1;
        sql = sql.replace(/\?/g, (function() {
          return '$' + index++;
        }));
      }
      return callback(null, sql, bindvars);
    };

    return PostgreSQLConnectionFactory;

  })(ConnectionFactory);

  PostgreSQLClient = (function(superClass) {
    extend(PostgreSQLClient, superClass);

    function PostgreSQLClient() {
      var options;
      options = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      PostgreSQLClient.__super__.constructor.apply(this, slice.call(options).concat([new PostgreSQLConnectionFactory()]));
    }

    return PostgreSQLClient;

  })(SQLClient);

  PostgreSQLClientPool = (function(superClass) {
    extend(PostgreSQLClientPool, superClass);

    function PostgreSQLClientPool() {
      var options;
      options = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      PostgreSQLClientPool.__super__.constructor.apply(this, slice.call(options).concat([new PostgreSQLConnectionFactory()]));
    }

    return PostgreSQLClientPool;

  })(SQLClientPool);

  exports.PostgreSQLConnectionFactory = PostgreSQLConnectionFactory;

  exports.PostgreSQLClient = PostgreSQLClient;

  exports.PostgreSQLClientPool = PostgreSQLClientPool;

  PostgreSQLConnectionFactory2 = (function(superClass) {
    extend(PostgreSQLConnectionFactory2, superClass);

    function PostgreSQLConnectionFactory2() {
      this.close_connection = bind(this.close_connection, this);
      this.open_connection = bind(this.open_connection, this);
      this._parse_connect_string = bind(this._parse_connect_string, this);
      PostgreSQLConnectionFactory2.__super__.constructor.call(this);
      this.pg_pools_by_connect_string = {};
    }

    PostgreSQLConnectionFactory2.prototype._connect_string_regexp = /^([^:]+):\/\/([^:]+):([^@]+)@([^:\/]+)(:([0-9]+))?(.*)$/;

    PostgreSQLConnectionFactory2.prototype._parse_connect_string = function(connect_string) {
      var config, matches, name, parsed_path, qs, value;
      if (typeof connect_string === 'string' && this._connect_string_regexp.test(connect_string)) {
        matches = connect_string.match(this._connect_string_regexp);
        config = {};
        config.database = matches[1];
        config.user = matches[2];
        config.password = matches[3];
        config.host = matches[4];
        if (matches[6] != null) {
          config.port = parseInt(matches[6]);
        }
        path = matches[7];
        parsed_path = Url.parse(path);
        config.database = parsed_path.pathname.substring(1);
        if (parsed_path.query != null) {
          qs = querystring.parse(parsed_path.query);
          for (name in qs) {
            value = qs[name];
            if (value === 'true') {
              value = true;
            } else if (value === 'false') {
              value = false;
            } else if (("" + value) === ("" + (parseInt(value)))) {
              value = parseInt(value);
            }
            config[name] = value;
          }
        }
        return config;
      } else {
        return connect_string;
      }
    };

    PostgreSQLConnectionFactory2.prototype.open_connection = function(connect_string, callback) {
      var key, pg_pool;
      key = connect_string;
      if (typeof key !== 'string') {
        key = JSON.stringify(key);
      }
      pg_pool = this.pg_pools_by_connect_string[key];
      if (pg_pool == null) {
        pg_pool = new pg.Pool(this._parse_connect_string(connect_string));
        this.pg_pools_by_connect_string[key] = pg_pool;
      }
      return pg_pool.connect((function(_this) {
        return function(err, client, done_fn) {
          var connection;
          connection = client;
          if (connection != null) {
            connection._sqlclient_done = done_fn;
            connection._pg_pool_key = key;
          }
          return callback(err, connection);
        };
      })(this));
    };

    PostgreSQLConnectionFactory2.prototype.close_connection = function(connection, callback) {
      if ((connection != null ? connection._sqlclient_done : void 0) != null) {
        connection._sqlclient_done();
        return typeof callback === "function" ? callback(null) : void 0;
      } else {
        return PostgreSQLConnectionFactory2.__super__.close_connection.apply(this, arguments).close_connection(connection, callback);
      }
    };

    return PostgreSQLConnectionFactory2;

  })(PostgreSQLConnectionFactory);

  PostgreSQLClient2 = (function(superClass) {
    extend(PostgreSQLClient2, superClass);

    function PostgreSQLClient2() {
      var options;
      options = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      PostgreSQLClient2.__super__.constructor.apply(this, slice.call(options).concat([new PostgreSQLConnectionFactory2()]));
    }

    return PostgreSQLClient2;

  })(SQLClient);

  PostgreSQLClientPool2 = (function(superClass) {
    extend(PostgreSQLClientPool2, superClass);

    function PostgreSQLClientPool2() {
      var options;
      options = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.close = bind(this.close, this);
      this.destroy = bind(this.destroy, this);
      PostgreSQLClientPool2.__super__.constructor.apply(this, slice.call(options).concat([new PostgreSQLConnectionFactory2()]));
    }

    PostgreSQLClientPool2.prototype.destroy = function(client, callback) {
      if (client != null) {
        return client.disconnect(callback);
      } else {
        return typeof callback === "function" ? callback() : void 0;
      }
    };

    PostgreSQLClientPool2.prototype.close = function(callback) {
      return PostgreSQLClientPool2.__super__.close.call(this, (function(_this) {
        return function() {
          var args, key, pg_pool, pools_to_close, ref, ref1;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          pools_to_close = (ref = _this.factory) != null ? ref.pg_pools_by_connect_string : void 0;
          ref1 = pools_to_close != null ? pools_to_close : {};
          for (key in ref1) {
            pg_pool = ref1[key];
            if (pg_pool != null) {
              pg_pool.end();
            }
          }
          return typeof callback === "function" ? callback.apply(null, args) : void 0;
        };
      })(this));
    };

    return PostgreSQLClientPool2;

  })(SQLClientPool);

  exports.PostgreSQLConnectionFactory2 = PostgreSQLConnectionFactory2;

  exports.PostgreSQLClient2 = PostgreSQLClient2;

  exports.PostgreSQLClientPool2 = PostgreSQLClientPool2;

}).call(this);
